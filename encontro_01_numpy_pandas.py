# -*- coding: utf-8 -*-
"""Encontro_01_Numpy_Pandas.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OEa5pTzZ8E96pNnPBIMItjRhIGmiijeN

# Disciplina de Mineração de Dados
## Programa de Pós-graduação em Informática (PPGI)

### Prof. Dr. Marlon Marcon

# Encontro 1: Introdução à Mineração de Dados e Python para Análise de Dados

**Objetivos:**
- Apresentar a disciplina, ementa, cronograma e avaliação.
- Introduzir os conceitos fundamentais de Mineração de Dados e o processo KDD.
- Discutir as principais tarefas e formas de representação de conhecimento em Mineração de Dados.
- Capacitar os alunos no uso das bibliotecas NumPy e Pandas para manipulação e análise de dados em Python.

## Parte 1: NumPy (Numerical Python)

NumPy é a biblioteca fundamental para computação científica em Python. Ela fornece suporte para arrays multidimensionais de alta performance e ferramentas para trabalhar com esses arrays.
"""

# Importar a biblioteca NumPy
import numpy as np

lista = [1,"casa",3,4]
array = np.array(lista)
print(array)
print(lista)

"""### 1.1 Criação de Arrays NumPy

Arrays NumPy (ndarrays) podem ser criados de diversas formas:
"""

# A partir de uma lista Python
lista1 = [1, 2, 3, 4, 5]
array1 = np.array(lista1)
print(f"Array a partir de lista: {array1}")

lista2 = [[1, 2, 3], [4, 5, 6]]
array2 = np.array(lista2)
print(f"Array 2D a partir de lista de listas:\n{array2}")

# Usando np.arange() - similar ao range do Python
array_arange = np.arange(0, 10, 2) # Início, Fim (exclusivo), Passo
print(f"Array com arange: {array_arange}")

# Usando np.zeros() e np.ones()
array_zeros = np.zeros((2, 3)) # Shape do array (2 linhas, 3 colunas)
print(f"Array de zeros:\n{array_zeros}")

array_ones = np.ones((3, 2))
print(f"Array de uns:\n{array_ones}")

# Usando np.linspace() - números igualmente espaçados em um intervalo
array_linspace = np.linspace(0, 1, 5) # Início, Fim, Número de pontos
print(f"Array com linspace: {array_linspace}")

# Usando np.random para criar arrays com números aleatórios
array_rand = np.random.rand(2, 2) # Números aleatórios entre 0 e 1 com shape (2,2)
print(f"Array com random.rand:\n{array_rand}")

array_randn = np.random.randn(2, 2) # Números aleatórios de uma distribuição normal padrão
print(f"Array com random.randn:\n{array_randn}")

array_randint = np.random.randint(0, 100, (2, 3)) # Inteiros aleatórios (Início, Fim (exclusivo), Shape)
print(f"Array com random.randint:\n{array_randint}")

"""### 1.2 Atributos do ndarray

Arrays NumPy possuem atributos importantes que descrevem suas características:
"""

print(f"Array2: \n{array2}")
print(f"Shape de array2: {array2.shape}") # Dimensões do array (linhas, colunas)
print(f"dtype de array2: {array2.dtype}") # Tipo de dado dos elementos
print(f"ndim de array2: {array2.ndim}") # Número de dimensões
print(f"size de array2: {array2.size}") # Número total de elementos

"""### 1.3 Indexação e Fatiamento (Slicing)

Acessar e modificar partes de arrays NumPy é crucial.
"""

array_idx = np.arange(10, 20)
print(f"Array para indexação: {array_idx}")

# Acessando um elemento
print(f"Elemento no índice 3: {array_idx[3]}")

# Fatiamento (slicing) [start:stop:step]
print(f"Elementos do índice 2 ao 5 (exclusive): {array_idx[2:5]}")
print(f"Elementos do início ao índice 4 (exclusive): {array_idx[:4]}")
print(f"Elementos do índice 5 ao fim: {array_idx[5:]}")
print(f"Elementos com passo 2: {array_idx[::2]}")

# Indexação em arrays 2D
array2d_idx = np.array([[10, 11, 12], [13, 14, 15], [16, 17, 18]])
print(f"Array 2D para indexação:\n{array2d_idx}")

# Acessando um elemento (linha, coluna)
print(f"Elemento na linha 1, coluna 2: {array2d_idx[1, 2]}") # ou array2d_idx[1][2]

# Fatiando linhas e colunas
print(f"Primeiras duas linhas, todas as colunas:\n{array2d_idx[:2, :]}")
print(f"Todas as linhas, coluna 1:\n{array2d_idx[:, 1]}")
print(f"Sub-array (linhas 0 e 1, colunas 1 e 2):\n{array2d_idx[:2, 1:]}")

# Indexação booleana
array_bool = np.array([1, 5, 2, 8, 3, 7])
condicao = array_bool > 3
print(f"Array para indexação booleana: {array_bool}")
print(f"Condição (elementos > 3): {condicao}")
print(f"Elementos que satisfazem a condição: {array_bool[condicao]}")

"""### 1.4 Operações Vetorizadas e Funções Universais (ufuncs)

NumPy permite operações elemento a elemento sem a necessidade de loops explícitos, o que é muito eficiente.
"""

arr_a = np.array([1, 2, 3])
arr_b = np.array([4, 5, 6])

print(f"Array A: {arr_a}")
print(f"Array B: {arr_b}")

# Operações aritméticas elemento a elemento
print(f"A + B: {arr_a + arr_b}")
print(f"A - B: {arr_a - arr_b}")
print(f"A * B: {arr_a * arr_b}")
print(f"A / B: {arr_a / arr_b}")
print(f"A ** 2: {arr_a ** 2}")

# Funções Universais (ufuncs)
print(f"Raiz quadrada de A: {np.sqrt(arr_a)}")
print(f"Exponencial de A: {np.exp(arr_a)}")
print(f"Seno de A: {np.sin(arr_a)}")
print(f"Logaritmo de A: {np.log(arr_a)}")

"""### 1.5 Agregações

Calcular somas, médias, mínimos, máximos, etc.
"""

array_agg = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
print(f"Array para agregação:\n{array_agg}")

print(f"Soma de todos os elementos: {array_agg.sum()}") # ou np.sum(array_agg)
print(f"Média de todos os elementos: {array_agg.mean()}")
print(f"Valor mínimo: {array_agg.min()}")
print(f"Valor máximo: {array_agg.max()}")
print(f"Desvio padrão: {array_agg.std()}")

# Agregações ao longo de eixos (axis)
# axis=0 opera ao longo das linhas (calcula para cada coluna)
print(f"Soma ao longo das linhas (para cada coluna): {array_agg.sum(axis=0)}")
# axis=1 opera ao longo das colunas (calcula para cada linha)
print(f"Soma ao longo das colunas (para cada linha): {array_agg.sum(axis=1)}")

"""### 1.6 Broadcasting

Broadcasting descreve como o NumPy trata arrays com shapes diferentes durante operações aritméticas. Sujeito a certas restrições, o array menor é "transmitido" (broadcasted) através do array maior para que eles tenham shapes compatíveis.
"""

array_broad = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
escalar = 10
print(f"Array original:\n{array_broad}")

# Array com escalar
print(f"Array + escalar:\n{array_broad + escalar}")

array_linha = np.array([10, 20, 30]) # Shape (3,)
print(f"Array linha: {array_linha}")
print(f"Array + Array linha (broadcasting):\n{array_broad + array_linha}")

array_coluna = np.array([[10], [20], [30]]) # Shape (3,1)
print(f"Array coluna:\n{array_coluna}")
print(f"Array + Array coluna (broadcasting):\n{array_broad + array_coluna}")

"""### Exercícios Práticos com NumPy

1. Crie um array NumPy 1D com números de 0 a 9.
2. Crie um array NumPy 2D (3x3) com valores de True.
3. Extraia todos os números ímpares do array criado no exercício 1.
4. Substitua todos os números ímpares no array do exercício 1 por -1.
5. Crie um array 2D de shape (5,3) com números inteiros aleatórios entre 1 e 100. Calcule a média, mínimo e máximo por coluna.
"""

# Exercício 1
arr_ex1 = np.arange(10)
print(f"Ex1: {arr_ex1}")

# Exercício 2
arr_ex2 = np.full((3,3), True)
# Alternativa: arr_ex2 = np.ones((3,3), dtype=bool)
print(f"Ex2:\n{arr_ex2}")

# Exercício 3
arr_ex3 = arr_ex1[arr_ex1 % 2 != 0]
print(f"Ex3: {arr_ex3}")

# Exercício 4
arr_ex4 = arr_ex1.copy() # Evitar modificar o original para outros exercícios
arr_ex4[arr_ex4 % 2 != 0] = -1
print(f"Ex4: {arr_ex4}")

# Exercício 5
arr_ex5 = np.random.randint(1, 101, (5,3))
print(f"Ex5 - Array:\n{arr_ex5}")
print(f"Ex5 - Média por coluna: {arr_ex5.mean(axis=0)}")
print(f"Ex5 - Mínimo por coluna: {arr_ex5.min(axis=0)}")
print(f"Ex5 - Máximo por coluna: {arr_ex5.max(axis=0)}")

"""## Parte 2: Pandas (Python Data Analysis Library)

Pandas é construída sobre NumPy e fornece estruturas de dados de alto nível e ferramentas de análise de dados fáceis de usar. As principais estruturas são Series (1D) e DataFrame (2D).
"""

# Importar a biblioteca Pandas
import pandas as pd

"""### 2.1 Series

Uma Series é um array unidimensional rotulado capaz de armazenar qualquer tipo de dado (inteiros, strings, floats, objetos Python, etc.). Os rótulos do eixo são chamados coletivamente de índice.
"""

# Criando uma Series a partir de uma lista
s_lista = pd.Series([10, 20, 30, 40, 50])
print(f"Series a partir de lista:\n{s_lista}")

# Criando uma Series com índice personalizado
s_indice = pd.Series([1, 2, 3], index=['a', 'b', 'c'])
print(f"Series com índice personalizado:\n{s_indice}")

# Acessando elementos
print(f"Elemento no índice 0 de s_lista: {s_lista[0]}")
print(f"Elemento no rótulo 'b' de s_indice: {s_indice['b']}")

# Operações em Series (similares ao NumPy)
print(f"s_lista * 2:\n{s_lista * 2}")
print(f"s_lista > 25:\n{s_lista[s_lista > 25]}")

"""### 2.2 DataFrames

Um DataFrame é uma estrutura de dados tabular bidimensional, rotulada, com colunas de tipos potencialmente diferentes. Você pode pensar nele como uma planilha, uma tabela SQL ou um dicionário de objetos Series.
"""

# Criando um DataFrame a partir de um dicionário de listas
dados = {
    'Nome': ['Ana', 'Bruno', 'Carla', 'Daniel'],
    'Idade': [23, 34, 29, 42],
    'Cidade': ['SP', 'RJ', 'BH', 'POA']
}
df_dict = pd.DataFrame(dados)
print(f"DataFrame a partir de dicionário:\n{df_dict}")

# Criando um DataFrame a partir de uma lista de dicionários
lista_de_dicts = [
    {'Nome': 'Eva', 'Idade': 28, 'Cidade': 'SSA'},
    {'Nome': 'Fábio', 'Idade': 31, 'Cidade': 'REC'}
]
df_lista_dicts = pd.DataFrame(lista_de_dicts)
print(f"\nDataFrame a partir de lista de dicionários:\n{df_lista_dicts}")

"""### 2.3 Leitura e Escrita de Arquivos

Pandas pode ler e escrever dados de/para uma variedade de formatos de arquivo, como CSV, Excel, JSON, SQL, etc.
"""

# Criando um arquivo CSV de exemplo
data_csv = {'col1': [1, 2], 'col2': [3, 4]}
df_para_csv = pd.DataFrame(data_csv)
df_para_csv.to_csv('exemplo.csv', index=False) # index=False para não salvar o índice do DataFrame no arquivo

# Lendo um arquivo CSV
df_lido_csv = pd.read_csv('exemplo.csv')
print(f"DataFrame lido do CSV:\n{df_lido_csv}")

# (Opcional) Para ler Excel, você pode precisar instalar openpyxl: !pip install openpyxl
# df_para_excel = pd.DataFrame({'colA': [10,20], 'colB': ['X','Y']})
# df_para_excel.to_excel('exemplo.xlsx', sheet_name='Planilha1', index=False)
# df_lido_excel = pd.read_excel('exemplo.xlsx', sheet_name='Planilha1')
# print(f"\nDataFrame lido do Excel:\n{df_lido_excel}")

"""### 2.4 Visualização e Exploração de Dados

Pandas oferece várias funções para rapidamente inspecionar e entender seus dados.
"""

# Usando o DataFrame df_dict criado anteriormente
print(f"Primeiras 2 linhas (head):\n{df_dict.head(2)}")
print(f"\nÚltimas 2 linhas (tail):\n{df_dict.tail(2)}")
print(f"\nInformações sobre o DataFrame (info):")
df_dict.info()
print(f"\nEstatísticas descritivas (describe):\n{df_dict.describe(include='all')}") # include='all' para incluir colunas não numéricas

print(f"\nShape do DataFrame: {df_dict.shape}")
print(f"Tipos de dados das colunas (dtypes):\n{df_dict.dtypes}")
print(f"Nomes das colunas: {df_dict.columns}")
print(f"Índice do DataFrame: {df_dict.index}")

"""### 2.5 Seleção e Indexação

Selecionar subconjuntos de dados é uma tarefa fundamental.
"""

# Selecionando uma coluna (retorna uma Series)
nomes = df_dict['Nome']
print(f"Coluna 'Nome':\n{nomes}")
print(type(nomes))

# Selecionando múltiplas colunas (retorna um DataFrame)
nome_idade = df_dict[['Nome', 'Idade']]
print(f"\nColunas 'Nome' e 'Idade':\n{nome_idade}")

# Seleção por rótulo de linha com .loc[]
# .loc[rótulo_linha, rótulo_coluna]
print(f"\nLinha com índice 1:\n{df_dict.loc[1]}")
print(f"\nNome da pessoa na linha 1: {df_dict.loc[1, 'Nome']}")
print(f"\nLinhas 0 e 2, colunas 'Nome' e 'Cidade':\n{df_dict.loc[[0, 2], ['Nome', 'Cidade']]}")

# Seleção por posição inteira com .iloc[]
# .iloc[posição_linha, posição_coluna]
print(f"\nLinha na posição 1 (segunda linha):\n{df_dict.iloc[1]}")
print(f"\nElemento na linha 1, coluna 0: {df_dict.iloc[1, 0]}")
print(f"\nPrimeiras duas linhas, primeiras duas colunas:\n{df_dict.iloc[:2, :2]}")

# Seleção condicional
mais_de_30 = df_dict[df_dict['Idade'] > 30]
print(f"\nPessoas com mais de 30 anos:\n{mais_de_30}")

# Condições múltiplas
# & para AND, | para OR, ~ para NOT. Use parênteses para cada condição.
ana_ou_daniel = df_dict[(df_dict['Nome'] == 'Ana') | (df_dict['Nome'] == 'Daniel')]
print(f"\nAna ou Daniel:\n{ana_ou_daniel}")

"""### 2.6 Manipulação de Dados Ausentes (Missing Data)

Dados ausentes são comuns e precisam ser tratados.
"""

# Criando um DataFrame com dados ausentes (NaN - Not a Number)
dados_ausentes = {
    'A': [1, 2, np.nan, 4],
    'B': [5, np.nan, np.nan, 8],
    'C': ['x', 'y', 'z', 'w']
}
df_ausentes = pd.DataFrame(dados_ausentes)
print(f"DataFrame com dados ausentes:\n{df_ausentes}")

# Verificando dados ausentes
print(f"\nVerificando isnull():\n{df_ausentes.isnull()}")
print(f"\nContagem de ausentes por coluna:\n{df_ausentes.isnull().sum()}")

# Removendo dados ausentes com .dropna()
# axis=0 remove linhas com NaN, axis=1 remove colunas com NaN
# how='any' remove se houver qualquer NaN, how='all' remove se todos forem NaN
print(f"\nRemovendo linhas com qualquer NaN:\n{df_ausentes.dropna(axis=0, how='any')}")

# Preenchendo dados ausentes com .fillna()
print(f"\nPreenchendo NaN com 0:\n{df_ausentes.fillna(value=0)}")

# Preenchendo com a média da coluna (apenas para colunas numéricas)
df_ausentes_copia = df_ausentes.copy()
df_ausentes_copia['A'] = df_ausentes_copia['A'].fillna(df_ausentes_copia['A'].mean())
df_ausentes_copia['B'] = df_ausentes_copia['B'].fillna(df_ausentes_copia['B'].median()) # Usando mediana para B
print(f"\nPreenchendo NaN com média/mediana da coluna:\n{df_ausentes_copia}")

"""### 2.7 Operações Básicas e Agrupamento (groupby)

Pandas permite diversas operações, incluindo adicionar/remover colunas e agrupar dados.
"""

# Adicionando uma nova coluna
df_dict['Salario'] = [5000, 7000, 4500, 8000]
print(f"DataFrame com nova coluna 'Salario':\n{df_dict}")

# Removendo uma coluna
# df_dict_sem_cidade = df_dict.drop('Cidade', axis=1) # axis=1 para coluna
# print(f"\nDataFrame sem a coluna 'Cidade':\n{df_dict_sem_cidade}")

# Estatísticas descritivas por coluna
print(f"\nMédia de Idade: {df_dict['Idade'].mean()}")
print(f"Soma dos Salários: {df_dict['Salario'].sum()}")
print(f"Valores únicos na coluna 'Cidade': {df_dict['Cidade'].unique()}")
print(f"Contagem de valores na coluna 'Cidade':\n{df_dict['Cidade'].value_counts()}")

# Agrupamento com .groupby()
# O groupby envolve uma combinação de dividir o objeto, aplicar uma função e combinar os resultados.
dados_grupo = {
    'Empresa': ['GOOG', 'GOOG', 'MSFT', 'MSFT', 'FB', 'FB'],
    'Pessoa': ['Sam', 'Charlie', 'Amy', 'Vanessa', 'Carl', 'Sarah'],
    'Vendas': [200, 120, 340, 124, 243, 350]
}
df_grupo = pd.DataFrame(dados_grupo)
print(f"\nDataFrame para groupby:\n{df_grupo}")

grupo_por_empresa = df_grupo.groupby('Empresa')
print(f"\nMédia de vendas por empresa:\n{grupo_por_empresa['Vendas'].mean()}")
print(f"\nSoma de vendas por empresa:\n{grupo_por_empresa['Vendas'].sum()}")
print(f"\nContagem de pessoas por empresa:\n{grupo_por_empresa['Pessoa'].count()}")

# Agregação múltipla
print(f"\nAgregação múltipla (soma, média, contagem) de vendas por empresa:\n{grupo_por_empresa['Vendas'].agg(['sum', 'mean', 'count'])}")

grupo_por_empresa.describe()

"""### Exercícios Práticos com Pandas

1. Crie um DataFrame com informações de pelo menos 5 alunos (Nome, Idade, Curso, Semestre).
2. Carregue um dataset CSV simples (ex: `iris.csv` ou `titanic.csv` - você pode encontrar links para eles online ou usar os do `seaborn` se tiver instalado: `import seaborn as sns; df_iris = sns.load_dataset('iris')`). Se usar um dataset local, faça o upload para o Colab.
3. Explore o DataFrame carregado: mostre as primeiras 5 linhas, as últimas 3 linhas, as dimensões (shape), os tipos de dados de cada coluna e as estatísticas descritivas.
4. Selecione apenas as colunas que são do tipo numérico (float ou int) do DataFrame carregado.
5. Filtre o DataFrame para mostrar apenas as linhas onde uma coluna numérica específica é maior que um valor à sua escolha (ex: no Iris, `sepal_length > 5.0`).
6. Verifique se há dados ausentes no DataFrame. Se houver, conte quantos por coluna e proponha uma estratégia para tratá-los (preencher com média/mediana/moda ou remover).
7. Agrupe os dados por uma coluna categórica (ex: a coluna `species` no Iris) e calcule a média de todas as colunas numéricas para cada grupo.
"""

# Exercício 1
dados_alunos = {
    'Nome': ['Miguel', 'Sofia', 'Arthur', 'Helena', 'Bernardo'],
    'Idade': [20, 22, 21, 23, 20],
    'Curso': ['Computação', 'Engenharia', 'Computação', 'Direito', 'Engenharia'],
    'Semestre': [3, 5, 4, 6, 3]
}
df_alunos = pd.DataFrame(dados_alunos)
print(f"Ex1 - DataFrame Alunos:\n{df_alunos}")

# Exercício 2: Carregar dataset Iris (exemplo com seaborn para facilidade no Colab)
# Se for usar um CSV local:
# from google.colab import files
# uploaded = files.upload() # Isso abrirá uma caixa de diálogo para upload
# import io
# df_iris = pd.read_csv(io.BytesIO(uploaded['nome_do_seu_arquivo_iris.csv']))

import seaborn as sns
df_iris = sns.load_dataset('iris')
print(f"\nEx2 - Dataset Iris carregado (primeiras linhas):\n{df_iris.head()}")

# Exercício 3
print(f"\nEx3 - Primeiras 5 linhas:\n{df_iris.head(5)}")
print(f"\nEx3 - Últimas 3 linhas:\n{df_iris.tail(3)}")
print(f"\nEx3 - Shape: {df_iris.shape}")
print(f"\nEx3 - Tipos de dados:\n{df_iris.dtypes}")
print(f"\nEx3 - Estatísticas descritivas:\n{df_iris.describe(include='all')}")

# Exercício 4
df_iris_numerico = df_iris.select_dtypes(include=[np.number])
print(f"\nEx4 - Colunas numéricas:\n{df_iris_numerico.head()}")

# Exercício 5
df_filtrado = df_iris[df_iris['sepal_length'] > 7.0]
print(f"\nEx5 - Iris com sepal_length > 7.0:\n{df_filtrado}")

# Exercício 6
print(f"\nEx6 - Dados ausentes por coluna:\n{df_iris.isnull().sum()}")
# O dataset Iris do seaborn geralmente não tem dados ausentes.
# Se tivesse, uma estratégia poderia ser:
# Para colunas numéricas: df_iris['nome_coluna_numerica'].fillna(df_iris['nome_coluna_numerica'].median(), inplace=True)
# Para colunas categóricas: df_iris['nome_coluna_categorica'].fillna(df_iris['nome_coluna_categorica'].mode()[0], inplace=True)
print("O dataset Iris carregado geralmente não possui dados ausentes.")

# Exercício 7
media_por_especie = df_iris.groupby('species').mean() # .mean() em um GroupBy calcula a média das colunas numéricas
print(f"\nEx7 - Média das colunas numéricas por espécie:\n{media_por_especie}")

"""## Conclusão do Encontro 1 (Prática)

Neste notebook, revisamos os fundamentos de NumPy para operações numéricas eficientes e Pandas para manipulação e análise de dados tabulares. Estas são ferramentas essenciais para qualquer projeto de Mineração de Dados em Python.
"""